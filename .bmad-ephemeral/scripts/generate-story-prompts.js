#!/usr/bin/env node

/**
 * Generate task-specific prompts for Claude Code Web from story markdown files
 * Usage: node generate-story-prompts.js <story-md-file>
 */

const fs = require('fs');
const path = require('path');

function parseStoryFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split('\n');

  // Extract story ID from filename
  const filename = path.basename(filePath, '.md');
  const storyId = filename.split('-').slice(0, 2).join('-');

  // Extract title
  const titleLine = lines.find(line => line.startsWith('# Story'));
  const title = titleLine ? titleLine.replace(/^# Story \d+-\d+:\s*/, '') : 'Unknown Story';

  // Extract story statement
  let asA = '', iWant = '', soThat = '';
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes('As an **') || lines[i].includes('As a **')) {
      asA = lines[i].match(/As an? \*\*([^*]+)\*\*/)?.[1] || '';
    }
    if (lines[i].includes('I want **')) {
      iWant = lines[i].match(/I want \*\*([^*]+)\*\*/)?.[1] || '';
    }
    if (lines[i].includes('so that **')) {
      soThat = lines[i].match(/so that \*\*([^*]+)\*\*/)?.[1] || '';
    }
  }

  // Extract tasks with their subtasks
  const tasks = [];
  let currentTask = null;
  let inTasksSection = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (line.startsWith('## Tasks / Subtasks')) {
      inTasksSection = true;
      continue;
    }

    if (inTasksSection && line.startsWith('## ')) {
      break; // End of tasks section
    }

    if (inTasksSection) {
      // Main task (no leading spaces before checkbox)
      if (line.match(/^- \[ \]/)) {
        if (currentTask) {
          tasks.push(currentTask);
        }
        const taskMatch = line.match(/^- \[ \] (.+?)(?:\s*\(AC:[^)]+\))?$/);
        if (taskMatch) {
          currentTask = {
            title: taskMatch[1].trim(),
            subtasks: [],
            acRef: line.match(/\(AC:\s*([^)]+)\)/)?.[1] || ''
          };
        }
      }
      // Subtask (has leading spaces before checkbox)
      else if (line.match(/^\s+- \[ \]/)) {
        const subtaskMatch = line.match(/^\s+- \[ \] (.+?)(?:\s*\(AC:[^)]+\))?$/);
        if (subtaskMatch && currentTask) {
          currentTask.subtasks.push(subtaskMatch[1].trim());
        }
      }
    }
  }

  // Add last task
  if (currentTask) {
    tasks.push(currentTask);
  }

  return {
    storyId,
    title,
    asA,
    iWant,
    soThat,
    tasks,
    filepath: filePath
  };
}

function generatePrompt(story, taskIndex, task) {
  const promptNumber = String(taskIndex + 1).padStart(2, '0');
  const taskTitle = task.title.replace(/[^a-z0-9]+/gi, '-').toLowerCase().slice(0, 50);

  let prompt = `# Story ${story.storyId}: ${story.title}
## Task ${promptNumber}: ${task.title}

**Story Context:**
- **As a** ${story.asA}
- **I want** ${story.iWant}
- **So that** ${story.soThat}

**Acceptance Criteria:** ${task.acRef}

**This Task:**
${task.title}
`;

  if (task.subtasks.length > 0) {
    prompt += `\n**Subtasks:**\n`;
    task.subtasks.forEach((subtask, idx) => {
      prompt += `${idx + 1}. ${subtask}\n`;
    });
  }

  prompt += `\n**Instructions:**

Read the full story context from:
- Story file: ${story.filepath}
- Context file: ${story.filepath.replace('.md', '.context.xml')}

Then implement this task according to:
1. The acceptance criteria (AC: ${task.acRef})
2. The Dev Notes section in the story file
3. The Architecture Alignment section
4. The Security Considerations section

**Development Guidelines:**
- Follow the project structure specified in the story
- Use the API route patterns from architecture.md
- Implement RLS policies as specified
- Add appropriate error handling with handleApiError()
- Use Zod validation schemas
- Follow TypeScript best practices
- Add inline comments for complex logic
- Consider security implications at every step

**Testing:**
- Write unit tests for new functions
- Write integration tests for API routes
- Ensure RLS policies are tested
- Test error cases and edge cases

**When Complete:**
- Mark the task checkbox as done in the story file
- Update the manifest file
- Document any deviations or issues encountered
- Note any follow-up tasks discovered

---
*Generated by execute-dev-story-claude-code-web workflow*
`;

  return {
    filename: `${promptNumber}-${taskTitle}.md`,
    content: prompt
  };
}

function generateManifest(story, prompts) {
  let manifest = `# Development Manifest: Story ${story.storyId}

**Story:** ${story.title}

**Generated:** ${new Date().toISOString()}

**Status:** In Progress

## Task Prompts

`;

  prompts.forEach((prompt, idx) => {
    manifest += `### ${idx + 1}. ${story.tasks[idx].title}
- [ ] Prompt: \`${prompt.filename}\`
- [ ] Implementation complete
- [ ] Tests written
- [ ] Story file updated

`;
  });

  manifest += `## Progress Tracking

- Total tasks: ${prompts.length}
- Completed: 0
- In progress: 0
- Remaining: ${prompts.length}

## Notes

Add notes here as you work through the tasks:
-

## Issues / Blockers

Document any issues or blockers encountered:
-

---
*Update this file as you complete each task*
`;

  return manifest;
}

// Main execution
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.error('Usage: node generate-story-prompts.js <story-md-file>');
    process.exit(1);
  }

  const storyFile = args[0];

  if (!fs.existsSync(storyFile)) {
    console.error(`Error: Story file not found: ${storyFile}`);
    process.exit(1);
  }

  console.log(`Parsing story file: ${storyFile}`);
  const story = parseStoryFile(storyFile);

  console.log(`\nStory: ${story.storyId} - ${story.title}`);
  console.log(`Tasks found: ${story.tasks.length}`);

  // Create output directory
  const outputDir = path.join(
    path.dirname(storyFile),
    'prompts',
    story.storyId
  );

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  console.log(`\nOutput directory: ${outputDir}`);

  // Generate prompt files
  const prompts = [];
  story.tasks.forEach((task, idx) => {
    const prompt = generatePrompt(story, idx, task);
    const promptPath = path.join(outputDir, prompt.filename);
    fs.writeFileSync(promptPath, prompt.content);
    prompts.push(prompt);
    console.log(`  ‚úì Generated: ${prompt.filename}`);
  });

  // Generate manifest
  const manifest = generateManifest(story, prompts);
  const manifestPath = path.join(outputDir, 'MANIFEST.md');
  fs.writeFileSync(manifestPath, manifest);
  console.log(`  ‚úì Generated: MANIFEST.md`);

  console.log(`\n‚úÖ Successfully generated ${prompts.length} prompt files + manifest`);
  console.log(`\nüìÅ Location: ${outputDir}`);
  console.log(`\nüìù Next steps:`);
  console.log(`   1. Open Claude Code Web (https://claude.ai/code)`);
  console.log(`   2. Copy-paste prompts sequentially starting with 01-*.md`);
  console.log(`   3. Update MANIFEST.md as you complete each task`);
  console.log(`   4. Mark checkboxes in the story file as tasks are done`);
}

module.exports = { parseStoryFile, generatePrompt, generateManifest };
