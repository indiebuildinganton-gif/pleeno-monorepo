<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>3</storyId>
    <title>Authentication & Authorization Framework</title>
    <status>drafted</status>
    <generatedAt>2025-11-13</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>.bmad-ephemeral/stories/1-3-authentication-authorization-framework.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>an authentication system with role-based access control</iWant>
    <soThat>users can securely log in and access features based on their roles</soThat>
    <tasks>
- Set up Supabase Auth integration (AC: 1, 2)
  - Configure Supabase Auth in Next.js environment variables
  - Install Supabase client libraries (@supabase/supabase-js, @supabase/ssr)
  - Create shared auth package: packages/auth/src/
  - Implement createServerClient() in packages/database/src/server.ts
  - Implement createClient() for client-side auth
  - Configure JWT token handling with HTTP-only cookies

- Implement user registration flow (AC: 1)
  - Create signup API route: POST /api/auth/signup
  - Create signup page: apps/shell/app/(auth)/signup/page.tsx
  - Validate email format and password strength (Zod schema)
  - Create user record in users table after auth.users creation
  - Set initial role (agency_admin for first user, agency_user otherwise)
  - Send welcome email via Resend (optional for MVP)

- Implement login/logout flows (AC: 1, 2)
  - Create login API route: POST /api/auth/login
  - Create login page: apps/shell/app/(auth)/login/page.tsx
  - Implement logout API route: POST /api/auth/logout
  - Handle JWT session creation and storage in HTTP-only cookies
  - Implement password reset flow: apps/shell/app/(auth)/reset-password/page.tsx
  - Create useAuth hook in packages/auth/src/hooks/useAuth.ts

- Implement role-based access control (AC: 3)
  - Store user role in users table (role ENUM: 'agency_admin', 'agency_user')
  - Include role in JWT claims via Supabase Auth metadata
  - Create requireRole() middleware helper
  - Create hasRole() client-side utility function
  - Test role-based UI rendering (hide admin-only buttons for agency_user)

- Implement authentication middleware (AC: 4)
  - Create middleware.ts in apps/shell/
  - Validate JWT on protected routes (/dashboard/*, /agency/*, /entities/*, /payments/*, /reports/*)
  - Redirect unauthenticated users to /login
  - Refresh expired tokens automatically
  - Handle cookie updates across multi-zones (shared cookie domain)

- Implement agency context setting (AC: 5)
  - Extract agency_id from JWT claims (user.app_metadata.agency_id)
  - Set PostgreSQL session variable: SET LOCAL app.current_agency_id
  - Create setAgencyContext() function in packages/database/src/middleware.ts
  - Call setAgencyContext() in server-side data fetching
  - Verify RLS policies filter correctly by agency_id

- Create auth UI components (AC: 1)
  - LoginForm component (packages/ui/src/components/auth/)
  - SignupForm component
  - LogoutButton component
  - PasswordResetForm component
  - Use React Hook Form + Zod validation
  - Style with Shadcn UI components (Button, Input, Form)

- Write authentication test suite (AC: 1, 2, 3, 4)
  - Test: Successful signup creates user and auth record
  - Test: Successful login sets JWT cookie
  - Test: Logout clears JWT cookie
  - Test: Middleware redirects unauthenticated requests to /login
  - Test: Agency Admin can access admin-only routes
  - Test: Agency User cannot access admin-only routes
  - Test: RLS context is set correctly on authenticated requests
  - Test: Password reset sends email and updates password
    </tasks>
  </story>

  <acceptanceCriteria>
1. Given the multi-tenant database schema exists, When I implement authentication and authorization, Then users can register, log in, and log out securely

2. And user sessions are managed with secure JWT tokens or session cookies

3. And role-based access control (RBAC) distinguishes between Agency Admin and Agency User roles

4. And authentication middleware protects API routes and pages

5. And agency_id is automatically set in the security context on login
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/epics.md" title="Epic Breakdown" section="Story 1.3: Authentication &amp; Authorization Framework">
        Defines story requirements: authentication system with role-based access control, secure JWT tokens, RBAC for Agency Admin and Agency User roles, middleware protection for API routes, and automatic agency_id context setting.
      </doc>
      <doc path="docs/architecture.md" title="System Architecture" section="Authentication Pattern">
        Details Supabase Auth integration with @supabase/ssr, JWT validation middleware, cookie sharing across multi-zones, and RLS integration via auth.uid(). Includes complete middleware implementation pattern.
      </doc>
      <doc path="docs/architecture.md" title="System Architecture" section="Security Architecture">
        Defines multi-tenant isolation strategy, RLS policy patterns, JWT claims structure, authorization levels (Agency Admin vs Agency User permissions), data encryption requirements, and audit trail specifications.
      </doc>
      <doc path="docs/architecture.md" title="System Architecture" section="Project Structure">
        Specifies Turborepo monorepo with packages/auth/ for shared auth utilities, packages/database/ for Supabase clients, apps/shell/ for auth pages, and auth package structure with hooks and utilities.
      </doc>
      <doc path=".bmad-ephemeral/stories/1-2-multi-tenant-database-schema-with-rls.md" title="Previous Story" section="Database Schema">
        Story 1.2 creates agencies and users tables with RLS policies. Users table includes role ENUM ('agency_admin', 'agency_user'), agency_id FK, and set_agency_context() database function for RLS context propagation.
      </doc>
    </docs>
    <code>
      <!-- No existing code - greenfield implementation. Key files to create:
           - packages/auth/src/hooks/useAuth.ts
           - packages/auth/src/utils/permissions.ts
           - packages/database/src/server.ts (createServerClient)
           - packages/database/src/middleware.ts (setAgencyContext)
           - apps/shell/middleware.ts (auth middleware)
           - apps/shell/app/(auth)/login/page.tsx
           - apps/shell/app/(auth)/signup/page.tsx
           - packages/ui/src/components/auth/* (auth forms) -->
    </code>
    <dependencies>
      <node>
        <package name="@supabase/supabase-js" version="latest" reason="Supabase client library for authentication and database access" />
        <package name="@supabase/ssr" version="latest" reason="Server-side rendering support for Supabase Auth with Next.js" />
        <package name="react-hook-form" version="7.66.0" reason="Form state management for auth forms (login, signup, password reset)" />
        <package name="@hookform/resolvers" version="latest" reason="Zod resolver for React Hook Form validation" />
        <package name="zod" version="4.x" reason="Schema validation for email format and password strength" />
        <package name="resend" version="6.4.2" reason="Email sending for welcome emails and password reset (optional for MVP)" />
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">Use Turborepo monorepo structure with packages/auth/ for shared authentication utilities and packages/database/ for Supabase client setup. Auth pages in apps/shell/app/(auth)/ route group.</constraint>
    <constraint type="authentication">Use Supabase Auth exclusively for user management. Store JWT in HTTP-only cookies (not localStorage). Include agency_id and role in JWT app_metadata claims.</constraint>
    <constraint type="authorization">Two roles only: 'agency_admin' and 'agency_user'. Role checks must be server-side in middleware/API routes. Client-side hasRole() is for UI rendering only, not security.</constraint>
    <constraint type="security">All passwords hashed by Supabase Auth (bcrypt). JWT tokens use HTTP-only cookies for XSS protection. RLS policies enforce multi-tenant isolation at database level.</constraint>
    <constraint type="database">User records created in both auth.users (Supabase Auth) and public.users (application data) with matching UUIDs. set_agency_context() function must be called to propagate JWT claims to RLS.</constraint>
    <constraint type="middleware">Middleware must protect routes: /dashboard/*, /agency/*, /entities/*, /payments/*, /reports/*. Redirect unauthenticated users to /login. Auto-refresh expired tokens.</constraint>
    <constraint type="testing">Write tests for signup/login/logout flows, middleware protection, role-based access, and RLS context setting. Verify JWT includes agency_id and role.</constraint>
  </constraints>

  <interfaces>
    <interface name="createServerClient" kind="function" signature="createServerClient() => SupabaseClient" path="packages/database/src/server.ts">
      Server-side Supabase client with cookie handling for SSR. Used in Server Components and API routes.
    </interface>
    <interface name="createClient" kind="function" signature="createClient() => SupabaseClient" path="packages/database/src/client.ts">
      Client-side Supabase client for browser-based authentication operations.
    </interface>
    <interface name="setAgencyContext" kind="function" signature="setAgencyContext(supabase: SupabaseClient) => Promise&lt;void&gt;" path="packages/database/src/middleware.ts">
      Extracts agency_id from JWT claims and sets PostgreSQL session variable for RLS filtering.
    </interface>
    <interface name="useAuth" kind="hook" signature="useAuth() => { user, session, signIn, signUp, signOut }" path="packages/auth/src/hooks/useAuth.ts">
      React hook providing auth state and operations (login, signup, logout).
    </interface>
    <interface name="requireRole" kind="middleware" signature="requireRole(role: string) => NextMiddleware" path="packages/auth/src/utils/permissions.ts">
      Server-side middleware to enforce role-based access control.
    </interface>
    <interface name="hasRole" kind="function" signature="hasRole(user: User, role: string) => boolean" path="packages/auth/src/utils/permissions.ts">
      Client-side utility to check if user has specific role (UI rendering only).
    </interface>
    <interface name="POST /api/auth/signup" kind="REST endpoint" signature="{ email, password, full_name } => { user, session }" path="apps/shell/app/api/auth/signup/route.ts">
      User registration endpoint creating records in auth.users and public.users.
    </interface>
    <interface name="POST /api/auth/login" kind="REST endpoint" signature="{ email, password } => { user, session }" path="apps/shell/app/api/auth/login/route.ts">
      User login endpoint returning JWT in HTTP-only cookie.
    </interface>
    <interface name="POST /api/auth/logout" kind="REST endpoint" signature="{} => { success: boolean }" path="apps/shell/app/api/auth/logout/route.ts">
      User logout endpoint clearing JWT cookie.
    </interface>
  </interfaces>

  <tests>
    <standards>
      Use Vitest for unit tests and integration tests. Place tests in __tests__/ directories or co-located with components as .test.ts files. Test Server Components with React Testing Library. E2E tests for critical flows using Playwright.
    </standards>
    <locations>
      - packages/auth/src/__tests__/ (auth utility tests)
      - packages/database/src/__tests__/ (client and middleware tests)
      - apps/shell/app/api/auth/__tests__/ (API route tests)
      - apps/shell/__tests__/e2e/ (E2E authentication flows)
    </locations>
    <ideas>
      <test ac="1">Test successful signup creates both auth.users and public.users records with matching UUIDs</test>
      <test ac="1">Test signup validates email format (reject invalid emails)</test>
      <test ac="1">Test signup enforces password strength (min 8 chars, complexity requirements)</test>
      <test ac="1">Test successful login returns JWT with agency_id and role in app_metadata</test>
      <test ac="1">Test login with invalid credentials returns error</test>
      <test ac="1">Test logout clears JWT cookie from browser</test>
      <test ac="2">Test JWT stored in HTTP-only cookie (not accessible to JavaScript)</test>
      <test ac="2">Test JWT auto-refresh when expired</test>
      <test ac="3">Test hasRole() returns true for agency_admin with admin role</test>
      <test ac="3">Test hasRole() returns false for agency_user with admin role check</test>
      <test ac="3">Test requireRole() middleware blocks agency_user from admin-only routes</test>
      <test ac="4">Test middleware redirects unauthenticated request to /login</test>
      <test ac="4">Test middleware allows authenticated request to /dashboard</test>
      <test ac="4">Test middleware protects all specified routes (/agency/*, /entities/*, etc.)</test>
      <test ac="5">Test setAgencyContext() extracts agency_id from JWT claims</test>
      <test ac="5">Test RLS filters queries by agency_id after login</test>
      <test ac="5">Test user cannot access other agency's data (cross-tenant isolation)</test>
    </ideas>
  </tests>
</story-context>
